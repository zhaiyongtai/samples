<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0068)http://dbus.freedesktop.org/doc/dbus-tutorial.html#glib-typemappings -->
<HTML><HEAD><TITLE>D-Bus Tutorial</TITLE>
<META http-equiv=Content-Type content="text/html; charset=ISO-8859-1">
<META content="MSHTML 6.00.6000.16735" name=GENERATOR></HEAD>
<BODY text=black vLink=#840084 aLink=#0000ff link=#0000ff bgColor=white>
<DIV class=article lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H1 class=title><A name=index></A>D-Bus Tutorial</H1></DIV>
<DIV>
<DIV class=authorgroup>
<DIV class=author>
<H3 class=author><SPAN class=firstname>Havoc</SPAN> <SPAN 
class=surname>Pennington</SPAN></H3>
<DIV class=affiliation><SPAN class=orgname>Red Hat, Inc.<BR></SPAN>
<DIV class=address>
<P><CODE class=email>&lt;<A 
href="mailto:hp@pobox.com">hp@pobox.com</A>&gt;</CODE></P></DIV></DIV></DIV>
<DIV class=author>
<H3 class=author><SPAN class=firstname>David</SPAN> <SPAN 
class=surname>Wheeler</SPAN></H3></DIV>
<DIV class=author>
<H3 class=author><SPAN class=firstname>John</SPAN> <SPAN 
class=surname>Palmieri</SPAN></H3>
<DIV class=affiliation><SPAN class=orgname>Red Hat, Inc.<BR></SPAN>
<DIV class=address>
<P><CODE class=email>&lt;<A 
href="mailto:johnp@redhat.com">johnp@redhat.com</A>&gt;</CODE></P></DIV></DIV></DIV>
<DIV class=author>
<H3 class=author><SPAN class=firstname>Colin</SPAN> <SPAN 
class=surname>Walters</SPAN></H3>
<DIV class=affiliation><SPAN class=orgname>Red Hat, Inc.<BR></SPAN>
<DIV class=address>
<P><CODE class=email>&lt;<A 
href="mailto:walters@redhat.com">walters@redhat.com</A>&gt;</CODE></P></DIV></DIV></DIV></DIV></DIV>
<DIV>
<P class=releaseinfo>Version 0.5.0</P></DIV></DIV>
<HR>
</DIV>
<DIV class=toc>
<P><B>Table of Contents</B></P>
<DL>
  <DT><SPAN class=sect1><A 
  href="http://dbus.freedesktop.org/doc/dbus-tutorial.html#meta">Tutorial Work 
  In Progress</A></SPAN>
  <DT><SPAN class=sect1><A 
  href="http://dbus.freedesktop.org/doc/dbus-tutorial.html#whatis">What is 
  D-Bus?</A></SPAN>
  <DD>
  <DL>
    <DT><SPAN class=sect2><A 
    href="http://dbus.freedesktop.org/doc/dbus-tutorial.html#uses">D-Bus 
    applications</A></SPAN></DT></DL>
  <DT><SPAN class=sect1><A 
  href="http://dbus.freedesktop.org/doc/dbus-tutorial.html#concepts">Concepts</A></SPAN>
  <DD>
  <DL>
    <DT><SPAN class=sect2><A 
    href="http://dbus.freedesktop.org/doc/dbus-tutorial.html#objects">Native 
    Objects and Object Paths</A></SPAN>
    <DT><SPAN class=sect2><A 
    href="http://dbus.freedesktop.org/doc/dbus-tutorial.html#members">Methods 
    and Signals</A></SPAN>
    <DT><SPAN class=sect2><A 
    href="http://dbus.freedesktop.org/doc/dbus-tutorial.html#interfaces">Interfaces</A></SPAN>
    <DT><SPAN class=sect2><A 
    href="http://dbus.freedesktop.org/doc/dbus-tutorial.html#proxies">Proxies</A></SPAN>
    <DT><SPAN class=sect2><A 
    href="http://dbus.freedesktop.org/doc/dbus-tutorial.html#bus-names">Bus 
    Names</A></SPAN>
    <DT><SPAN class=sect2><A 
    href="http://dbus.freedesktop.org/doc/dbus-tutorial.html#addresses">Addresses</A></SPAN>
    <DT><SPAN class=sect2><A 
    href="http://dbus.freedesktop.org/doc/dbus-tutorial.html#bigpicture">Big 
    Conceptual Picture</A></SPAN>
    <DT><SPAN class=sect2><A 
    href="http://dbus.freedesktop.org/doc/dbus-tutorial.html#messages">Messages 
    - Behind the Scenes</A></SPAN>
    <DT><SPAN class=sect2><A 
    href="http://dbus.freedesktop.org/doc/dbus-tutorial.html#callprocedure">Calling 
    a Method - Behind the Scenes</A></SPAN>
    <DT><SPAN class=sect2><A 
    href="http://dbus.freedesktop.org/doc/dbus-tutorial.html#signalprocedure">Emitting 
    a Signal - Behind the Scenes</A></SPAN>
    <DT><SPAN class=sect2><A 
    href="http://dbus.freedesktop.org/doc/dbus-tutorial.html#introspection">Introspection</A></SPAN></DT></DL>
  <DT><SPAN class=sect1><A 
  href="http://dbus.freedesktop.org/doc/dbus-tutorial.html#glib-client">GLib 
  API: Using Remote Objects</A></SPAN>
  <DD>
  <DL>
    <DT><SPAN class=sect2><A 
    href="http://dbus.freedesktop.org/doc/dbus-tutorial.html#glib-typemappings">D-Bus 
    - GLib type mappings</A></SPAN>
    <DT><SPAN class=sect2><A 
    href="http://dbus.freedesktop.org/doc/dbus-tutorial.html#sample-program-1">A 
    sample program</A></SPAN>
    <DT><SPAN class=sect2><A 
    href="http://dbus.freedesktop.org/doc/dbus-tutorial.html#glib-program-setup">Program 
    initalization</A></SPAN>
    <DT><SPAN class=sect2><A 
    href="http://dbus.freedesktop.org/doc/dbus-tutorial.html#glib-method-invocation">Understanding 
    method invocation</A></SPAN>
    <DT><SPAN class=sect2><A 
    href="http://dbus.freedesktop.org/doc/dbus-tutorial.html#glib-signal-connection">Connecting 
    to object signals</A></SPAN>
    <DT><SPAN class=sect2><A 
    href="http://dbus.freedesktop.org/doc/dbus-tutorial.html#glib-error-handling">Error 
    handling and remote exceptions</A></SPAN>
    <DT><SPAN class=sect2><A 
    href="http://dbus.freedesktop.org/doc/dbus-tutorial.html#glib-more-examples">More 
    examples of method invocation</A></SPAN>
    <DT><SPAN class=sect2><A 
    href="http://dbus.freedesktop.org/doc/dbus-tutorial.html#glib-generated-bindings">Generated 
    Bindings</A></SPAN></DT></DL>
  <DT><SPAN class=sect1><A 
  href="http://dbus.freedesktop.org/doc/dbus-tutorial.html#glib-server">GLib 
  API: Implementing Objects</A></SPAN>
  <DD>
  <DL>
    <DT><SPAN class=sect2><A 
    href="http://dbus.freedesktop.org/doc/dbus-tutorial.html#glib-annotations">Server-side 
    Annotations</A></SPAN></DT></DL>
  <DT><SPAN class=sect1><A 
  href="http://dbus.freedesktop.org/doc/dbus-tutorial.html#python-client">Python 
  API</A></SPAN>
  <DT><SPAN class=sect1><A 
  href="http://dbus.freedesktop.org/doc/dbus-tutorial.html#qt-client">Qt API: 
  Using Remote Objects</A></SPAN>
  <DT><SPAN class=sect1><A 
  href="http://dbus.freedesktop.org/doc/dbus-tutorial.html#qt-server">Qt API: 
  Implementing Objects</A></SPAN></DT></DL></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A name=meta></A>Tutorial Work In 
Progress</H2></DIV></DIV></DIV>
<P>This tutorial is not complete; it probably contains some useful information, 
but also has plenty of gaps. Right now, you'll also need to refer to the D-Bus 
specification, Doxygen reference documentation, and look at some examples of how 
other apps use D-Bus. </P>
<P>Enhancing the tutorial is definitely encouraged - send your patches or 
suggestions to the mailing list. If you create a D-Bus binding, please add a 
section to the tutorial for your binding, if only a short section with a couple 
of examples. </P></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A name=whatis></A>What is 
D-Bus?</H2></DIV></DIV></DIV>
<P>D-Bus is a system for <EM class=firstterm>interprocess communication</EM> 
(IPC). Architecturally, it has several layers: </P>
<DIV class=itemizedlist>
<UL type=disc>
  <LI>
  <P>A library, <EM class=firstterm>libdbus</EM>, that allows two applications 
  to connect to each other and exchange messages. </P>
  <LI>
  <P>A <EM class=firstterm>message bus daemon</EM> executable, built on libdbus, 
  that multiple applications can connect to. The daemon can route messages from 
  one application to zero or more other applications. </P>
  <LI>
  <P><EM class=firstterm>Wrapper libraries</EM> or <EM 
  class=firstterm>bindings</EM> based on particular application frameworks. For 
  example, libdbus-glib and libdbus-qt. There are also bindings to languages 
  such as Python. These wrapper libraries are the API most people should use, as 
  they simplify the details of D-Bus programming. libdbus is intended to be a 
  low-level backend for the higher level bindings. Much of the libdbus API is 
  only useful for binding implementation. </P></LI></UL></DIV>
<P></P>
<P>libdbus only supports one-to-one connections, just like a raw network socket. 
However, rather than sending byte streams over the connection, you send <EM 
class=firstterm>messages</EM>. Messages have a header identifying the kind of 
message, and a body containing a data payload. libdbus also abstracts the exact 
transport used (sockets vs. whatever else), and handles details such as 
authentication. </P>
<P>The message bus daemon forms the hub of a wheel. Each spoke of the wheel is a 
one-to-one connection to an application using libdbus. An application sends a 
message to the bus daemon over its spoke, and the bus daemon forwards the 
message to other connected applications as appropriate. Think of the daemon as a 
router. </P>
<P>The bus daemon has multiple instances on a typical computer. The first 
instance is a machine-global singleton, that is, a system daemon similar to 
sendmail or Apache. This instance has heavy security restrictions on what 
messages it will accept, and is used for systemwide communication. The other 
instances are created one per user login session. These instances allow 
applications in the user's session to communicate with one another. </P>
<P>The systemwide and per-user daemons are separate. Normal within-session IPC 
does not involve the systemwide message bus process and vice versa. </P>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=uses></A>D-Bus applications</H3></DIV></DIV></DIV>
<P>There are many, many technologies in the world that have "Inter-process 
communication" or "networking" in their stated purpose: <A 
href="http://www.omg.org/" target=_top>CORBA</A>, <A 
href="http://www.opengroup.org/dce/" target=_top>DCE</A>, <A 
href="http://www.microsoft.com/com/" target=_top>DCOM</A>, <A 
href="http://developer.kde.org/documentation/library/kdeqt/dcop.html" 
target=_top>DCOP</A>, <A href="http://www.xmlrpc.com/" target=_top>XML-RPC</A>, 
<A href="http://www.w3.org/TR/SOAP/" target=_top>SOAP</A>, <A 
href="http://www.mbus.org/" target=_top>MBUS</A>, <A 
href="http://www.zeroc.com/ice.html" target=_top>Internet Communications Engine 
(ICE)</A>, and probably hundreds more. Each of these is tailored for particular 
kinds of application. D-Bus is designed for two specific cases: </P>
<DIV class=itemizedlist>
<UL type=disc>
  <LI>
  <P>Communication between desktop applications in the same desktop session; to 
  allow integration of the desktop session as a whole, and address issues of 
  process lifecycle (when do desktop components start and stop running). </P>
  <LI>
  <P>Communication between the desktop session and the operating system, where 
  the operating system would typically include the kernel and any system daemons 
  or processes. </P></LI></UL></DIV>
<P></P>
<P>For the within-desktop-session use case, the GNOME and KDE desktops have 
significant previous experience with different IPC solutions such as CORBA and 
DCOP. D-Bus is built on that experience and carefully tailored to meet the needs 
of these desktop projects in particular. D-Bus may or may not be appropriate for 
other applications; the FAQ has some comparisons to other IPC systems. </P>
<P>The problem solved by the systemwide or communication-with-the-OS case is 
explained well by the following text from the Linux Hotplug project: </P>
<DIV class=blockquote>
<BLOCKQUOTE class=blockquote>
  <P>A gap in current Linux support is that policies with any sort of dynamic 
  "interact with user" component aren't currently supported. For example, that's 
  often needed the first time a network adapter or printer is connected, and to 
  determine appropriate places to mount disk drives. It would seem that such 
  actions could be supported for any case where a responsible human can be 
  identified: single user workstations, or any system which is remotely 
  administered. </P>
  <P>This is a classic "remote sysadmin" problem, where in this case hotplugging 
  needs to deliver an event from one security domain (operating system kernel, 
  in this case) to another (desktop for logged-in user, or remote sysadmin). Any 
  effective response must go the other way: the remote domain taking some action 
  that lets the kernel expose the desired device capabilities. (The action can 
  often be taken asynchronously, for example letting new hardware be idle until 
  a meeting finishes.) At this writing, Linux doesn't have widely adopted 
  solutions to such problems. However, the new D-Bus work may begin to solve 
  that problem. </P></BLOCKQUOTE></DIV>
<P></P>
<P>D-Bus may happen to be useful for purposes other than the one it was designed 
for. Its general properties that distinguish it from other forms of IPC are: 
</P>
<DIV class=itemizedlist>
<UL type=disc>
  <LI>
  <P>Binary protocol designed to be used asynchronously (similar in spirit to 
  the X Window System protocol). </P>
  <LI>
  <P>Stateful, reliable connections held open over time. </P>
  <LI>
  <P>The message bus is a daemon, not a "swarm" or distributed architecture. 
</P>
  <LI>
  <P>Many implementation and deployment issues are specified rather than left 
  ambiguous/configurable/pluggable. </P>
  <LI>
  <P>Semantics are similar to the existing DCOP system, allowing KDE to adopt it 
  more easily. </P>
  <LI>
  <P>Security features to support the systemwide mode of the message bus. 
  </P></LI></UL></DIV>
<P></P></DIV></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A 
name=concepts></A>Concepts</H2></DIV></DIV></DIV>
<P>Some basic concepts apply no matter what application framework you're using 
to write a D-Bus application. The exact code you write will be different for 
GLib vs. Qt vs. Python applications, however. </P>
<P>Here is a diagram (<A href="http://dbus.freedesktop.org/doc/diagram.png" 
target=_top>png</A> <A href="http://dbus.freedesktop.org/doc/diagram.svg" 
target=_top>svg</A>) that may help you visualize the concepts that follow. </P>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=objects></A>Native Objects and Object 
Paths</H3></DIV></DIV></DIV>
<P>Your programming framework probably defines what an "object" is like; usually 
with a base class. For example: java.lang.Object, GObject, QObject, python's 
base Object, or whatever. Let's call this a <EM class=firstterm>native 
object</EM>. </P>
<P>The low-level D-Bus protocol, and corresponding libdbus API, does not care 
about native objects. However, it provides a concept called an <EM 
class=firstterm>object path</EM>. The idea of an object path is that 
higher-level bindings can name native object instances, and allow remote 
applications to refer to them. </P>
<P>The object path looks like a filesystem path, for example an object could be 
named <CODE class=literal>/org/kde/kspread/sheets/3/cells/4/5</CODE>. 
Human-readable paths are nice, but you are free to create an object named <CODE 
class=literal>/com/mycompany/c5yo817y0c1y1c5b</CODE> if it makes sense for your 
application. </P>
<P>Namespacing object paths is smart, by starting them with the components of a 
domain name you own (e.g. <CODE class=literal>/org/kde</CODE>). This keeps 
different code modules in the same process from stepping on one another's toes. 
</P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=members></A>Methods and Signals</H3></DIV></DIV></DIV>
<P>Each object has <EM class=firstterm>members</EM>; the two kinds of member are 
<EM class=firstterm>methods</EM> and <EM class=firstterm>signals</EM>. Methods 
are operations that can be invoked on an object, with optional input (aka 
arguments or "in parameters") and output (aka return values or "out 
parameters"). Signals are broadcasts from the object to any interested observers 
of the object; signals may contain a data payload. </P>
<P>Both methods and signals are referred to by name, such as "Frobate" or 
"OnClicked". </P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=interfaces></A>Interfaces</H3></DIV></DIV></DIV>
<P>Each object supports one or more <EM class=firstterm>interfaces</EM>. Think 
of an interface as a named group of methods and signals, just as it is in GLib 
or Qt or Java. Interfaces define the <SPAN class=emphasis><EM>type</EM></SPAN> 
of an object instance. </P>
<P>DBus identifies interfaces with a simple namespaced string, something like 
<CODE class=literal>org.freedesktop.Introspectable</CODE>. Most bindings will 
map these interface names directly to the appropriate programming language 
construct, for example to Java interfaces or C++ pure virtual classes. 
</P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=proxies></A>Proxies</H3></DIV></DIV></DIV>
<P>A <EM class=firstterm>proxy object</EM> is a convenient native object created 
to represent a remote object in another process. The low-level DBus API involves 
manually creating a method call message, sending it, then manually receiving and 
processing the method reply message. Higher-level bindings provide proxies as an 
alternative. Proxies look like a normal native object; but when you invoke a 
method on the proxy object, the binding converts it into a DBus method call 
message, waits for the reply message, unpacks the return value, and returns it 
from the native method.. </P>
<P>In pseudocode, programming without proxies might look like this: </P><PRE class=programlisting>          Message message = new Message("/remote/object/path", "MethodName", arg1, arg2);
          Connection connection = getBusConnection();
          connection.send(message);
          Message reply = connection.waitForReply(message);
          if (reply.isError()) {
             
          } else {
             Object returnValue = reply.getReturnValue();
          }
        </PRE>
<P></P>
<P>Programming with proxies might look like this: </P><PRE class=programlisting>          Proxy proxy = new Proxy(getBusConnection(), "/remote/object/path");
          Object returnValue = proxy.MethodName(arg1, arg2);
        </PRE>
<P></P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=bus-names></A>Bus Names</H3></DIV></DIV></DIV>
<P>When each application connects to the bus daemon, the daemon immediately 
assigns it a name, called the <EM class=firstterm>unique connection name</EM>. A 
unique name begins with a ':' (colon) character. These names are never reused 
during the lifetime of the bus daemon - that is, you know a given name will 
always refer to the same application. An example of a unique name might be <CODE 
class=literal>:34-907</CODE>. The numbers after the colon have no meaning other 
than their uniqueness. </P>
<P>When a name is mapped to a particular application's connection, that 
application is said to <EM class=firstterm>own</EM> that name. </P>
<P>Applications may ask to own additional <EM class=firstterm>well-known 
names</EM>. For example, you could write a specification to define a name called 
<CODE class=literal>com.mycompany.TextEditor</CODE>. Your definition could 
specify that to own this name, an application should have an object at the path 
<CODE class=literal>/com/mycompany/TextFileManager</CODE> supporting the 
interface <CODE class=literal>org.freedesktop.FileHandler</CODE>. </P>
<P>Applications could then send messages to this bus name, object, and interface 
to execute method calls. </P>
<P>You could think of the unique names as IP addresses, and the well-known names 
as domain names. So <CODE class=literal>com.mycompany.TextEditor</CODE> might 
map to something like <CODE class=literal>:34-907</CODE> just as <CODE 
class=literal>mycompany.com</CODE> maps to something like <CODE 
class=literal>192.168.0.5</CODE>. </P>
<P>Names have a second important use, other than routing messages. They are used 
to track lifecycle. When an application exits (or crashes), its connection to 
the message bus will be closed by the operating system kernel. The message bus 
then sends out notification messages telling remaining applications that the 
application's names have lost their owner. By tracking these notifications, your 
application can reliably monitor the lifetime of other applications. </P>
<P>Bus names can also be used to coordinate single-instance applications. If you 
want to be sure only one <CODE class=literal>com.mycompany.TextEditor</CODE> 
application is running for example, have the text editor application exit if the 
bus name already has an owner. </P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=addresses></A>Addresses</H3></DIV></DIV></DIV>
<P>Applications using D-Bus are either servers or clients. A server listens for 
incoming connections; a client connects to a server. Once the connection is 
established, it is a symmetric flow of messages; the client-server distinction 
only matters when setting up the connection. </P>
<P>If you're using the bus daemon, as you probably are, your application will be 
a client of the bus daemon. That is, the bus daemon listens for connections and 
your application initiates a connection to the bus daemon. </P>
<P>A D-Bus <EM class=firstterm>address</EM> specifies where a server will 
listen, and where a client will connect. For example, the address <CODE 
class=literal>unix:path=/tmp/abcdef</CODE> specifies that the server will listen 
on a UNIX domain socket at the path <CODE class=literal>/tmp/abcdef</CODE> and 
the client will connect to that socket. An address can also specify TCP/IP 
sockets, or any other transport defined in future iterations of the D-Bus 
specification. </P>
<P>When using D-Bus with a message bus daemon, libdbus automatically discovers 
the address of the per-session bus daemon by reading an environment variable. It 
discovers the systemwide bus daemon by checking a well-known UNIX domain socket 
path (though you can override this address with an environment variable). </P>
<P>If you're using D-Bus without a bus daemon, it's up to you to define which 
application will be the server and which will be the client, and specify a 
mechanism for them to agree on the server's address. This is an unusual case. 
</P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=bigpicture></A>Big Conceptual 
Picture</H3></DIV></DIV></DIV>
<P>Pulling all these concepts together, to specify a particular method call on a 
particular object instance, a number of nested components have to be named: </P><PRE class=programlisting>          Address -&gt; [Bus Name] -&gt; Path -&gt; Interface -&gt; Method
        </PRE>
<P>The bus name is in brackets to indicate that it's optional -- you only 
provide a name to route the method call to the right application when using the 
bus daemon. If you have a direct connection to another application, bus names 
aren't used; there's no bus daemon. </P>
<P>The interface is also optional, primarily for historical reasons; DCOP does 
not require specifying the interface, instead simply forbidding duplicate method 
names on the same object instance. D-Bus will thus let you omit the interface, 
but if your method name is ambiguous it is undefined which method will be 
invoked. </P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=messages></A>Messages - Behind the 
Scenes</H3></DIV></DIV></DIV>
<P>D-Bus works by sending messages between processes. If you're using a 
sufficiently high-level binding, you may never work with messages directly. </P>
<P>There are 4 message types: </P>
<DIV class=itemizedlist>
<UL type=disc>
  <LI>
  <P>Method call messages ask to invoke a method on an object. </P>
  <LI>
  <P>Method return messages return the results of invoking a method. </P>
  <LI>
  <P>Error messages return an exception caused by invoking a method. </P>
  <LI>
  <P>Signal messages are notifications that a given signal has been emitted 
  (that an event has occurred). You could also think of these as "event" 
  messages. </P></LI></UL></DIV>
<P></P>
<P>A method call maps very simply to messages: you send a method call message, 
and receive either a method return message or an error message in reply. </P>
<P>Each message has a <EM class=firstterm>header</EM>, including <EM 
class=firstterm>fields</EM>, and a <EM class=firstterm>body</EM>, including <EM 
class=firstterm>arguments</EM>. You can think of the header as the routing 
information for the message, and the body as the payload. Header fields might 
include the sender bus name, destination bus name, method or signal name, and so 
forth. One of the header fields is a <EM class=firstterm>type signature</EM> 
describing the values found in the body. For example, the letter "i" means 
"32-bit integer" so the signature "ii" means the payload has two 32-bit 
integers. </P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=callprocedure></A>Calling a Method - Behind the 
Scenes</H3></DIV></DIV></DIV>
<P>A method call in DBus consists of two messages; a method call message sent 
from process A to process B, and a matching method reply message sent from 
process B to process A. Both the call and the reply messages are routed through 
the bus daemon. The caller includes a different serial number in each call 
message, and the reply message includes this number to allow the caller to match 
replies to calls. </P>
<P>The call message will contain any arguments to the method. The reply message 
may indicate an error, or may contain data returned by the method. </P>
<P>A method invocation in DBus happens as follows: </P>
<DIV class=itemizedlist>
<UL type=disc>
  <LI>
  <P>The language binding may provide a proxy, such that invoking a method on an 
  in-process object invokes a method on a remote object in another process. If 
  so, the application calls a method on the proxy, and the proxy constructs a 
  method call message to send to the remote process. </P>
  <LI>
  <P>For more low-level APIs, the application may construct a method call 
  message itself, without using a proxy. </P>
  <LI>
  <P>In either case, the method call message contains: a bus name belonging to 
  the remote process; the name of the method; the arguments to the method; an 
  object path inside the remote process; and optionally the name of the 
  interface that specifies the method. </P>
  <LI>
  <P>The method call message is sent to the bus daemon. </P>
  <LI>
  <P>The bus daemon looks at the destination bus name. If a process owns that 
  name, the bus daemon forwards the method call to that process. Otherwise, the 
  bus daemon creates an error message and sends it back as the reply to the 
  method call message. </P>
  <LI>
  <P>The receiving process unpacks the method call message. In a simple 
  low-level API situation, it may immediately run the method and send a method 
  reply message to the bus daemon. When using a high-level binding API, the 
  binding might examine the object path, interface, and method name, and convert 
  the method call message into an invocation of a method on a native object 
  (GObject, java.lang.Object, QObject, etc.), then convert the return value from 
  the native method into a method reply message. </P>
  <LI>
  <P>The bus daemon receives the method reply message and sends it to the 
  process that made the method call. </P>
  <LI>
  <P>The process that made the method call looks at the method reply and makes 
  use of any return values included in the reply. The reply may also indicate 
  that an error occurred. When using a binding, the method reply message may be 
  converted into the return value of of a proxy method, or into an exception. 
  </P></LI></UL></DIV>
<P></P>
<P>The bus daemon never reorders messages. That is, if you send two method call 
messages to the same recipient, they will be received in the order they were 
sent. The recipient is not required to reply to the calls in order, however; for 
example, it may process each method call in a separate thread, and return reply 
messages in an undefined order depending on when the threads complete. Method 
calls have a unique serial number used by the method caller to match reply 
messages to call messages. </P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=signalprocedure></A>Emitting a Signal - Behind the 
Scenes</H3></DIV></DIV></DIV>
<P>A signal in DBus consists of a single message, sent by one process to any 
number of other processes. That is, a signal is a unidirectional broadcast. The 
signal may contain arguments (a data payload), but because it is a broadcast, it 
never has a "return value." Contrast this with a method call (see <A 
title="Calling a Method - Behind the Scenes" 
href="http://dbus.freedesktop.org/doc/dbus-tutorial.html#callprocedure">the 
section called “Calling a Method - Behind the Scenes”</A>) where the method call 
message has a matching method reply message. </P>
<P>The emitter (aka sender) of a signal has no knowledge of the signal 
recipients. Recipients register with the bus daemon to receive signals based on 
"match rules" - these rules would typically include the sender and the signal 
name. The bus daemon sends each signal only to recipients who have expressed 
interest in that signal. </P>
<P>A signal in DBus happens as follows: </P>
<DIV class=itemizedlist>
<UL type=disc>
  <LI>
  <P>A signal message is created and sent to the bus daemon. When using the 
  low-level API this may be done manually, with certain bindings it may be done 
  for you by the binding when a native object emits a native signal or event. 
  </P>
  <LI>
  <P>The signal message contains the name of the interface that specifies the 
  signal; the name of the signal; the bus name of the process sending the 
  signal; and any arguments </P>
  <LI>
  <P>Any process on the message bus can register "match rules" indicating which 
  signals it is interested in. The bus has a list of registered match rules. 
</P>
  <LI>
  <P>The bus daemon examines the signal and determines which processes are 
  interested in it. It sends the signal message to these processes. </P>
  <LI>
  <P>Each process receiving the signal decides what to do with it; if using a 
  binding, the binding may choose to emit a native signal on a proxy object. If 
  using the low-level API, the process may just look at the signal sender and 
  name and decide what to do based on that. </P></LI></UL></DIV>
<P></P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=introspection></A>Introspection</H3></DIV></DIV></DIV>
<P>D-Bus objects may support the interface <CODE 
class=literal>org.freedesktop.DBus.Introspectable</CODE>. This interface has one 
method <CODE class=literal>Introspect</CODE> which takes no arguments and 
returns an XML string. The XML string describes the interfaces, methods, and 
signals of the object. See the D-Bus specification for more details on this 
introspection format. </P></DIV></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A name=glib-client></A>GLib API: Using 
Remote Objects</H2></DIV></DIV></DIV>
<P>The GLib binding is defined in the header file <CODE 
class=literal>&lt;dbus/dbus-glib.h&gt;</CODE>. </P>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=glib-typemappings></A>D-Bus - GLib type 
mappings</H3></DIV></DIV></DIV>
<P>The heart of the GLib bindings for D-Bus is the mapping it provides between 
D-Bus "type signatures" and GLib types (<CODE class=literal>GType</CODE>). The 
D-Bus type system is composed of a number of "basic" types, along with several 
"container" types. </P>
<DIV class=sect3 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H4 class=title><A name=glib-basic-typemappings></A>Basic type 
mappings</H4></DIV></DIV></DIV>
<P>Below is a list of the basic types, along with their associated mapping to a 
<CODE class=literal>GType</CODE>. </P>
<DIV class=informaltable>
<TABLE border=1>
  <COLGROUP>
  <COL>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>D-Bus basic type</TH>
    <TH>GType</TH>
    <TH>Free function</TH>
    <TH>Notes</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD><CODE class=literal>BYTE</CODE></TD>
    <TD><CODE class=literal>G_TYPE_UCHAR</CODE></TD>
    <TD>&nbsp;</TD>
    <TD>&nbsp;</TD></TR>
  <TR>
    <TD><CODE class=literal>BOOLEAN</CODE></TD>
    <TD><CODE class=literal>G_TYPE_BOOLEAN</CODE></TD>
    <TD>&nbsp;</TD>
    <TD>&nbsp;</TD></TR>
  <TR>
    <TD><CODE class=literal>INT16</CODE></TD>
    <TD><CODE class=literal>G_TYPE_INT</CODE></TD>
    <TD>&nbsp;</TD>
    <TD>Will be changed to a <CODE class=literal>G_TYPE_INT16</CODE> once GLib 
      has it</TD></TR>
  <TR>
    <TD><CODE class=literal>UINT16</CODE></TD>
    <TD><CODE class=literal>G_TYPE_UINT</CODE></TD>
    <TD>&nbsp;</TD>
    <TD>Will be changed to a <CODE class=literal>G_TYPE_UINT16</CODE> once 
      GLib has it</TD></TR>
  <TR>
    <TD><CODE class=literal>INT32</CODE></TD>
    <TD><CODE class=literal>G_TYPE_INT</CODE></TD>
    <TD>&nbsp;</TD>
    <TD>Will be changed to a <CODE class=literal>G_TYPE_INT32</CODE> once GLib 
      has it</TD></TR>
  <TR>
    <TD><CODE class=literal>UINT32</CODE></TD>
    <TD><CODE class=literal>G_TYPE_UINT</CODE></TD>
    <TD>&nbsp;</TD>
    <TD>Will be changed to a <CODE class=literal>G_TYPE_UINT32</CODE> once 
      GLib has it</TD></TR>
  <TR>
    <TD><CODE class=literal>INT64</CODE></TD>
    <TD><CODE class=literal>G_TYPE_GINT64</CODE></TD>
    <TD>&nbsp;</TD>
    <TD>&nbsp;</TD></TR>
  <TR>
    <TD><CODE class=literal>UINT64</CODE></TD>
    <TD><CODE class=literal>G_TYPE_GUINT64</CODE></TD>
    <TD>&nbsp;</TD>
    <TD>&nbsp;</TD></TR>
  <TR>
    <TD><CODE class=literal>DOUBLE</CODE></TD>
    <TD><CODE class=literal>G_TYPE_DOUBLE</CODE></TD>
    <TD>&nbsp;</TD>
    <TD>&nbsp;</TD></TR>
  <TR>
    <TD><CODE class=literal>STRING</CODE></TD>
    <TD><CODE class=literal>G_TYPE_STRING</CODE></TD>
    <TD><CODE class=literal>g_free</CODE></TD>
    <TD>&nbsp;</TD></TR>
  <TR>
    <TD><CODE class=literal>OBJECT_PATH</CODE></TD>
    <TD><CODE class=literal>DBUS_TYPE_G_PROXY</CODE></TD>
    <TD><CODE class=literal>g_object_unref</CODE></TD>
    <TD>The returned proxy does not have an interface set; use <CODE 
      class=literal>dbus_g_proxy_set_interface</CODE> to invoke 
  methods</TD></TR></TBODY></TABLE></DIV>
<P>As you can see, the basic mapping is fairly straightforward. </P></DIV>
<DIV class=sect3 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H4 class=title><A name=glib-container-typemappings></A>Container type 
mappings</H4></DIV></DIV></DIV>
<P>The D-Bus type system also has a number of "container" types, such as <CODE 
class=literal>DBUS_TYPE_ARRAY</CODE> and <CODE 
class=literal>DBUS_TYPE_STRUCT</CODE>. The D-Bus type system is fully recursive, 
so one can for example have an array of array of strings (i.e. type signature 
<CODE class=literal>aas</CODE>). </P>
<P>However, not all of these types are in common use; for example, at the time 
of this writing the author knows of no one using <CODE 
class=literal>DBUS_TYPE_STRUCT</CODE>, or a <CODE 
class=literal>DBUS_TYPE_ARRAY</CODE> containing any non-basic type. The approach 
the GLib bindings take is pragmatic; try to map the most common types in the 
most obvious way, and let using less common and more complex types be less 
"natural". </P>
<P>First, D-Bus type signatures which have an "obvious" corresponding built-in 
GLib type are mapped using that type: </P>
<DIV class=informaltable>
<TABLE border=1>
  <COLGROUP>
  <COL>
  <COL>
  <COL>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>D-Bus type signature</TH>
    <TH>Description</TH>
    <TH>GType</TH>
    <TH>C typedef</TH>
    <TH>Free function</TH>
    <TH>Notes</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD><CODE class=literal>as</CODE></TD>
    <TD>Array of strings</TD>
    <TD><CODE class=literal>G_TYPE_STRV</CODE></TD>
    <TD><CODE class=literal>char **</CODE></TD>
    <TD><CODE class=literal>g_strfreev</CODE></TD>
    <TD>&nbsp;</TD></TR>
  <TR>
    <TD><CODE class=literal>v</CODE></TD>
    <TD>Generic value container</TD>
    <TD><CODE class=literal>G_TYPE_VALUE</CODE></TD>
    <TD><CODE class=literal>GValue *</CODE></TD>
    <TD><CODE class=literal>g_value_unset</CODE></TD>
    <TD>The calling conventions for values expect that method callers have 
      allocated return values; see below.</TD></TR></TBODY></TABLE></DIV>
<P></P>
<P>The next most common recursive type signatures are arrays of basic values. 
The most obvious mapping for arrays of basic types is a <CODE 
class=literal>GArray</CODE>. Now, GLib does not provide a builtin <CODE 
class=literal>GType</CODE> for <CODE class=literal>GArray</CODE>. However, we 
actually need more than that - we need a "parameterized" type which includes the 
contained type. Why we need this we will see below. </P>
<P>The approach taken is to create these types in the D-Bus GLib bindings; 
however, there is nothing D-Bus specific about them. In the future, we hope to 
include such "fundamental" types in GLib itself. </P>
<DIV class=informaltable>
<TABLE border=1>
  <COLGROUP>
  <COL>
  <COL>
  <COL>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>D-Bus type signature</TH>
    <TH>Description</TH>
    <TH>GType</TH>
    <TH>C typedef</TH>
    <TH>Free function</TH>
    <TH>Notes</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD><CODE class=literal>ay</CODE></TD>
    <TD>Array of bytes</TD>
    <TD><CODE class=literal>DBUS_TYPE_G_BYTE_ARRAY</CODE></TD>
    <TD><CODE class=literal>GArray *</CODE></TD>
    <TD>g_array_free</TD>
    <TD>&nbsp;</TD></TR>
  <TR>
    <TD><CODE class=literal>au</CODE></TD>
    <TD>Array of uint</TD>
    <TD><CODE class=literal>DBUS_TYPE_G_UINT_ARRAY</CODE></TD>
    <TD><CODE class=literal>GArray *</CODE></TD>
    <TD>g_array_free</TD>
    <TD>&nbsp;</TD></TR>
  <TR>
    <TD><CODE class=literal>ai</CODE></TD>
    <TD>Array of int</TD>
    <TD><CODE class=literal>DBUS_TYPE_G_INT_ARRAY</CODE></TD>
    <TD><CODE class=literal>GArray *</CODE></TD>
    <TD>g_array_free</TD>
    <TD>&nbsp;</TD></TR>
  <TR>
    <TD><CODE class=literal>ax</CODE></TD>
    <TD>Array of int64</TD>
    <TD><CODE class=literal>DBUS_TYPE_G_INT64_ARRAY</CODE></TD>
    <TD><CODE class=literal>GArray *</CODE></TD>
    <TD>g_array_free</TD>
    <TD>&nbsp;</TD></TR>
  <TR>
    <TD><CODE class=literal>at</CODE></TD>
    <TD>Array of uint64</TD>
    <TD><CODE class=literal>DBUS_TYPE_G_UINT64_ARRAY</CODE></TD>
    <TD><CODE class=literal>GArray *</CODE></TD>
    <TD>g_array_free</TD>
    <TD>&nbsp;</TD></TR>
  <TR>
    <TD><CODE class=literal>ad</CODE></TD>
    <TD>Array of double</TD>
    <TD><CODE class=literal>DBUS_TYPE_G_DOUBLE_ARRAY</CODE></TD>
    <TD><CODE class=literal>GArray *</CODE></TD>
    <TD>g_array_free</TD>
    <TD>&nbsp;</TD></TR>
  <TR>
    <TD><CODE class=literal>ab</CODE></TD>
    <TD>Array of boolean</TD>
    <TD><CODE class=literal>DBUS_TYPE_G_BOOLEAN_ARRAY</CODE></TD>
    <TD><CODE class=literal>GArray *</CODE></TD>
    <TD>g_array_free</TD>
    <TD>&nbsp;</TD></TR></TBODY></TABLE></DIV>
<P></P>
<P>D-Bus also includes a special type DBUS_TYPE_DICT_ENTRY which is only valid 
in arrays. It's intended to be mapped to a "dictionary" type by bindings. The 
obvious GLib mapping here is GHashTable. Again, however, there is no builtin 
<CODE class=literal>GType</CODE> for a GHashTable. Moreover, just like for 
arrays, we need a parameterized type so that the bindings can communiate which 
types are contained in the hash table. </P>
<P>At present, only strings are supported. Work is in progress to include more 
types. </P>
<DIV class=informaltable>
<TABLE border=1>
  <COLGROUP>
  <COL>
  <COL>
  <COL>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>D-Bus type signature</TH>
    <TH>Description</TH>
    <TH>GType</TH>
    <TH>C typedef</TH>
    <TH>Free function</TH>
    <TH>Notes</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD><CODE class=literal>a{ss}</CODE></TD>
    <TD>Dictionary mapping strings to strings</TD>
    <TD><CODE class=literal>DBUS_TYPE_G_STRING_STRING_HASHTABLE</CODE></TD>
    <TD><CODE class=literal>GHashTable *</CODE></TD>
    <TD>g_hash_table_destroy</TD>
    <TD>&nbsp;</TD></TR></TBODY></TABLE></DIV>
<P></P></DIV>
<DIV class=sect3 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H4 class=title><A name=glib-generic-typemappings></A>Arbitrarily recursive type 
mappings</H4></DIV></DIV></DIV>
<P>Finally, it is possible users will want to write or invoke D-Bus methods 
which have arbitrarily complex type signatures not directly supported by these 
bindings. For this case, we have a <CODE class=literal>DBusGValue</CODE> which 
acts as a kind of special variant value which may be iterated over manually. The 
<CODE class=literal>GType</CODE> associated is <CODE 
class=literal>DBUS_TYPE_G_VALUE</CODE>. </P>
<P>TODO insert usage of <CODE class=literal>DBUS_TYPE_G_VALUE</CODE> here. 
</P></DIV></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=sample-program-1></A>A sample 
program</H3></DIV></DIV></DIV>
<P>Here is a D-Bus program using the GLib bindings. </P><PRE class=programlisting>      
int
main (int argc, char **argv)
{
  DBusGConnection *connection;
  GError *error;
  DBusGProxy *proxy;
  char **name_list;
  char **name_list_ptr;
  
  g_type_init ();

  error = NULL;
  connection = dbus_g_bus_get (DBUS_BUS_SESSION,
                               &amp;error);
  if (connection == NULL)
    {
      g_printerr ("Failed to open connection to bus: %s\n",
                  error-&gt;message);
      g_error_free (error);
      exit (1);
    }

  /* Create a proxy object for the "bus driver" (name "org.freedesktop.DBus") */
  
  proxy = dbus_g_proxy_new_for_name (connection,
                                     DBUS_SERVICE_DBUS,
                                     DBUS_PATH_DBUS,
                                     DBUS_INTERFACE_DBUS);

  /* Call ListNames method, wait for reply */
  error = NULL;
  if (!dbus_g_proxy_call (proxy, "ListNames", &amp;error, G_TYPE_INVALID,
                          G_TYPE_STRV, &amp;name_list, G_TYPE_INVALID))
    {
      /* Just do demonstrate remote exceptions versus regular GError */
      if (error-&gt;domain == DBUS_GERROR &amp;&amp; error-&gt;code == DBUS_GERROR_REMOTE_EXCEPTION)
        g_printerr ("Caught remote method exception %s: %s",
	            dbus_g_error_get_name (error),
	            error-&gt;message);
      else
        g_printerr ("Error: %s\n", error-&gt;message);
      g_error_free (error);
      exit (1);
    }

  /* Print the results */
 
  g_print ("Names on the message bus:\n");
  
  for (name_list_ptr = name_list; *name_list_ptr; name_list_ptr++)
    {
      g_print ("  %s\n", *name_list_ptr);
    }
  g_strfreev (name_list);

  g_object_unref (proxy);

  return 0;
}
</PRE>
<P></P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=glib-program-setup></A>Program 
initalization</H3></DIV></DIV></DIV>
<P>A connection to the bus is acquired using <CODE 
class=literal>dbus_g_bus_get</CODE>. Next, a proxy is created for the object 
"/org/freedesktop/DBus" with interface <CODE 
class=literal>org.freedesktop.DBus</CODE> on the service <CODE 
class=literal>org.freedesktop.DBus</CODE>. This is a proxy for the message bus 
itself. </P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=glib-method-invocation></A>Understanding method 
invocation</H3></DIV></DIV></DIV>
<P>You have a number of choices for method invocation. First, as used above, 
<CODE class=literal>dbus_g_proxy_call</CODE> sends a method call to the remote 
object, and blocks until a reply is recieved. The outgoing arguments are 
specified in the varargs array, terminated with <CODE 
class=literal>G_TYPE_INVALID</CODE>. Next, pointers to return values are 
specified, followed again by <CODE class=literal>G_TYPE_INVALID</CODE>. </P>
<P>To invoke a method asynchronously, use <CODE 
class=literal>dbus_g_proxy_begin_call</CODE>. This returns a <CODE 
class=literal>DBusGPendingCall</CODE> object; you may then set a notification 
function using <CODE class=literal>dbus_g_pending_call_set_notify</CODE>. 
</P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=glib-signal-connection></A>Connecting to object 
signals</H3></DIV></DIV></DIV>
<P>You may connect to signals using <CODE 
class=literal>dbus_g_proxy_add_signal</CODE> and <CODE 
class=literal>dbus_g_proxy_connect_signal</CODE>. You must invoke <CODE 
class=literal>dbus_g_proxy_add_signal</CODE> to specify the signature of your 
signal handlers; you may then invoke <CODE 
class=literal>dbus_g_proxy_connect_signal</CODE> multiple times. </P>
<P>Note that it will often be the case that there is no builtin marshaller for 
the type signature of a remote signal. In that case, you must generate a 
marshaller yourself by using <SPAN class=application>glib-genmarshal</SPAN>, and 
then register it using <CODE 
class=literal>dbus_g_object_register_marshaller</CODE>. </P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=glib-error-handling></A>Error handling and remote 
exceptions</H3></DIV></DIV></DIV>
<P>All of the GLib binding methods such as <CODE 
class=literal>dbus_g_proxy_end_call</CODE> return a <CODE 
class=literal>GError</CODE>. This <CODE class=literal>GError</CODE> can 
represent two different things: </P>
<DIV class=itemizedlist>
<UL type=disc>
  <LI>
  <P>An internal D-Bus error, such as an out-of-memory condition, an I/O error, 
  or a network timeout. Errors generated by the D-Bus library itself have the 
  domain <CODE class=literal>DBUS_GERROR</CODE>, and a corresponding code such 
  as <CODE class=literal>DBUS_GERROR_NO_MEMORY</CODE>. It will not be typical 
  for applications to handle these errors specifically. </P>
  <LI>
  <P>A remote D-Bus exception, thrown by the peer, bus, or service. D-Bus remote 
  exceptions have both a textual "name" and a "message". The GLib bindings store 
  this information in the <CODE class=literal>GError</CODE>, but some special 
  rules apply. </P>
  <P>The set error will have the domain <CODE class=literal>DBUS_GERROR</CODE> 
  as above, and will also have the code <CODE 
  class=literal>DBUS_GERROR_REMOTE_EXCEPTION</CODE>. In order to access the 
  remote exception name, you must use a special accessor, such as <CODE 
  class=literal>dbus_g_error_has_name</CODE> or <CODE 
  class=literal>dbus_g_error_get_name</CODE>. The remote exception detailed 
  message is accessible via the regular GError <CODE 
  class=literal>message</CODE> member. </P></LI></UL></DIV>
<P></P></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=glib-more-examples></A>More examples of method 
invocation</H3></DIV></DIV></DIV>
<DIV class=sect3 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H4 class=title><A name=glib-sending-stuff></A>Sending an integer and string, 
receiving an array of bytes</H4></DIV></DIV></DIV>
<P></P><PRE class=programlisting>  GArray *arr;
  
  error = NULL;
  if (!dbus_g_proxy_call (proxy, "Foobar", &amp;error,
                          G_TYPE_INT, 42, G_TYPE_STRING, "hello",
			  G_TYPE_INVALID,
			  DBUS_TYPE_G_UCHAR_ARRAY, &amp;arr, G_TYPE_INVALID))
    {
      /* Handle error */
    }
   g_assert (arr != NULL);
   printf ("got back %u values", arr-&gt;len);
</PRE>
<P></P></DIV>
<DIV class=sect3 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H4 class=title><A name=glib-sending-hash></A>Sending a 
GHashTable</H4></DIV></DIV></DIV>
<P></P><PRE class=programlisting>  GHashTable *hash = g_hash_table_new (g_str_hash, g_str_equal);
  guint32 ret;
  
  g_hash_table_insert (hash, "foo", "bar");
  g_hash_table_insert (hash, "baz", "whee");

  error = NULL;
  if (!dbus_g_proxy_call (proxy, "HashSize", &amp;error,
                          DBUS_TYPE_G_STRING_STRING_HASH, hash, G_TYPE_INVALID,
			  G_TYPE_UINT, &amp;ret, G_TYPE_INVALID))
    {
      /* Handle error */
    }
  g_assert (ret == 2);
  g_hash_table_destroy (hash);
</PRE>
<P></P></DIV>
<DIV class=sect3 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H4 class=title><A name=glib-receiving-bool-int></A>Receiving a boolean and a 
string</H4></DIV></DIV></DIV>
<P></P><PRE class=programlisting>  gboolean boolret;
  char *strret;
  
  error = NULL;
  if (!dbus_g_proxy_call (proxy, "GetStuff", &amp;error,
			  G_TYPE_INVALID,
                          G_TYPE_BOOLEAN, &amp;boolret,
                          G_TYPE_STRING, &amp;strret,
			  G_TYPE_INVALID))
    {
      /* Handle error */
    }
  printf ("%s %s", boolret ? "TRUE" : "FALSE", strret);
  g_free (strret);
</PRE>
<P></P></DIV>
<DIV class=sect3 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H4 class=title><A name=glib-sending-str-arrays></A>Sending two arrays of 
strings</H4></DIV></DIV></DIV>
<P></P><PRE class=programlisting>  /* NULL terminate */
  char *strs_static[] = {"foo", "bar", "baz", NULL};
  /* Take pointer to array; cannot pass array directly */
  char **strs_static_p = strs_static;
  char **strs_dynamic;

  strs_dynamic = g_new (char *, 4);
  strs_dynamic[0] = g_strdup ("hello");
  strs_dynamic[1] = g_strdup ("world");
  strs_dynamic[2] = g_strdup ("!");
  /* NULL terminate */
  strs_dynamic[3] = NULL;
  
  error = NULL;
  if (!dbus_g_proxy_call (proxy, "TwoStrArrays", &amp;error,
                          G_TYPE_STRV, strs_static_p,
                          G_TYPE_STRV, strs_dynamic,
			  G_TYPE_INVALID,
			  G_TYPE_INVALID))
    {
      /* Handle error */
    }
   g_strfreev (strs_dynamic);
</PRE>
<P></P></DIV>
<DIV class=sect3 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H4 class=title><A name=glib-getting-str-array></A>Sending a boolean, receiving 
an array of strings</H4></DIV></DIV></DIV>
<P></P><PRE class=programlisting>  char **strs;
  char **strs_p;
  gboolean blah;

  error = NULL;
  blah = TRUE;
  if (!dbus_g_proxy_call (proxy, "GetStrs", &amp;error,
                          G_TYPE_BOOLEAN, blah,
			  G_TYPE_INVALID,
                          G_TYPE_STRV, &amp;strs,
			  G_TYPE_INVALID))
    {
      /* Handle error */
    }
   for (strs_p = strs; *strs_p; strs_p++)
     printf ("got string: \"%s\"", *strs_p);
   g_strfreev (strs);
</PRE>
<P></P></DIV>
<DIV class=sect3 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H4 class=title><A name=glib-sending-variant></A>Sending a 
variant</H4></DIV></DIV></DIV>
<P></P><PRE class=programlisting>  GValue val = {0, };

  g_value_init (&amp;val, G_TYPE_STRING);
  g_value_set_string (&amp;val, "hello world");
  
  error = NULL;
  if (!dbus_g_proxy_call (proxy, "SendVariant", &amp;error,
                          G_TYPE_VALUE, &amp;val, G_TYPE_INVALID,
			  G_TYPE_INVALID))
    {
      /* Handle error */
    }
  g_assert (ret == 2);
  g_value_unset (&amp;val);
</PRE>
<P></P></DIV>
<DIV class=sect3 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H4 class=title><A name=glib-receiving-variant></A>Receiving a 
variant</H4></DIV></DIV></DIV>
<P></P><PRE class=programlisting>  GValue val = {0, };

  error = NULL;
  if (!dbus_g_proxy_call (proxy, "GetVariant", &amp;error, G_TYPE_INVALID,
                          G_TYPE_VALUE, &amp;val, G_TYPE_INVALID))
    {
      /* Handle error */
    }
  if (G_VALUE_TYPE (&amp;val) == G_TYPE_STRING)
    printf ("%s\n", g_value_get_string (&amp;val));
  else if (G_VALUE_TYPE (&amp;val) == G_TYPE_INT)
    printf ("%d\n", g_value_get_int (&amp;val));
  else
    ...
  g_value_unset (&amp;val);
</PRE>
<P></P></DIV></DIV>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=glib-generated-bindings></A>Generated 
Bindings</H3></DIV></DIV></DIV>
<P>By using the Introspection XML files, convenient client-side bindings can be 
automatically created to ease the use of a remote DBus object. </P>
<P>Here is a sample XML file which describes an object that exposes one method, 
named <CODE class=literal>ManyArgs</CODE>. </P><PRE class=programlisting>&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;node name="/com/example/MyObject"&gt;
  &lt;interface name="com.example.MyObject"&gt;
    &lt;method name="ManyArgs"&gt;
      &lt;arg type="u" name="x" direction="in" /&gt;
      &lt;arg type="s" name="str" direction="in" /&gt;
      &lt;arg type="d" name="trouble" direction="in" /&gt;
      &lt;arg type="d" name="d_ret" direction="out" /&gt;
      &lt;arg type="s" name="str_ret" direction="out" /&gt;
    &lt;/method&gt;
  &lt;/interface&gt;
&lt;/node&gt;
</PRE>
<P></P>
<P>Run <CODE class=literal>dbus-binding-tool --mode=glib-client <EM 
class=replaceable><CODE>FILENAME</CODE></EM> &gt; <EM 
class=replaceable><CODE>HEADER_NAME</CODE></EM></CODE> to generate the header 
file. For example: <SPAN><STRONG class=command>dbus-binding-tool 
--mode=glib-client my-object.xml &gt; my-object-bindings.h</STRONG></SPAN>. This 
will generate inline functions with the following prototypes: </P><PRE class=programlisting>/* This is a blocking call */
gboolean
com_example_MyObject_many_args (DBusGProxy *proxy, const guint IN_x,
                                const char * IN_str, const gdouble IN_trouble,
                                gdouble* OUT_d_ret, char ** OUT_str_ret,
                                GError **error);

/* This is a non-blocking call */
DBusGProxyCall*
com_example_MyObject_many_args_async (DBusGProxy *proxy, const guint IN_x,
                                      const char * IN_str, const gdouble IN_trouble,
                                      com_example_MyObject_many_args_reply callback,
                                      gpointer userdata);

/* This is the typedef for the non-blocking callback */
typedef void
(*com_example_MyObject_many_args_reply)
(DBusGProxy *proxy, gdouble OUT_d_ret, char * OUT_str_ret,
 GError *error, gpointer userdata);
</PRE>
<P>The first argument in all functions is a <CODE class=literal>DBusGProxy 
*</CODE>, which you should create with the usual <CODE 
class=literal>dbus_g_proxy_new_*</CODE> functions. Following that are the "in" 
arguments, and then either the "out" arguments and a <CODE class=literal>GError 
*</CODE> for the synchronous (blocking) function, or callback and user data 
arguments for the asynchronous (non-blocking) function. The callback in the 
asynchronous function passes the <CODE class=literal>DBusGProxy *</CODE>, the 
returned "out" arguments, an <CODE class=literal>GError *</CODE> which is set if 
there was an error otherwise <CODE class=literal>NULL</CODE>, and the user data. 
</P>
<P>As with the server-side bindings support (see <A 
title="GLib API: Implementing Objects" 
href="http://dbus.freedesktop.org/doc/dbus-tutorial.html#glib-server">the 
section called “GLib API: Implementing Objects”</A>), the exact behaviour of the 
client-side bindings can be manipulated using "annotations". Currently the only 
annotation used by the client bindings is <CODE 
class=literal>org.freedesktop.DBus.GLib.NoReply</CODE>, which sets the flag 
indicating that the client isn't expecting a reply to the method call, so a 
reply shouldn't be sent. This is often used to speed up rapid method calls where 
there are no "out" arguments, and not knowing if the method succeeded is an 
acceptable compromise to half the traffic on the bus. </P></DIV></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A name=glib-server></A>GLib API: 
Implementing Objects</H2></DIV></DIV></DIV>
<P>At the moment, to expose a GObject via D-Bus, you must write XML by hand 
which describes the methods exported by the object. In the future, this manual 
step will be obviated by the upcoming GLib introspection support. </P>
<P>Here is a sample XML file which describes an object that exposes one method, 
named <CODE class=literal>ManyArgs</CODE>. </P><PRE class=programlisting>&lt;?xml version="1.0" encoding="UTF-8" ?&gt;

&lt;node name="/com/example/MyObject"&gt;

  &lt;interface name="com.example.MyObject"&gt;
    &lt;annotation name="org.freedesktop.DBus.GLib.CSymbol" value="my_object"/&gt;
    &lt;method name="ManyArgs"&gt;
      &lt;!-- This is optional, and in this case is redunundant --&gt;
      &lt;annotation name="org.freedesktop.DBus.GLib.CSymbol" value="my_object_many_args"/&gt;
      &lt;arg type="u" name="x" direction="in" /&gt;
      &lt;arg type="s" name="str" direction="in" /&gt;
      &lt;arg type="d" name="trouble" direction="in" /&gt;
      &lt;arg type="d" name="d_ret" direction="out" /&gt;
      &lt;arg type="s" name="str_ret" direction="out" /&gt;
    &lt;/method&gt;
  &lt;/interface&gt;
&lt;/node&gt;
</PRE>
<P></P>
<P>This XML is in the same format as the D-Bus introspection XML format. Except 
we must include an "annotation" which give the C symbols corresponding to the 
object implementation prefix (<CODE class=literal>my_object</CODE>). In 
addition, if particular methods symbol names deviate from C convention (i.e. 
<CODE class=literal>ManyArgs</CODE> -&gt; <CODE class=literal>many_args</CODE>), 
you may specify an annotation giving the C symbol. </P>
<P>Once you have written this XML, run <CODE class=literal>dbus-binding-tool 
--mode=glib-server <EM class=replaceable><CODE>FILENAME</CODE></EM> &gt; <EM 
class=replaceable><CODE>HEADER_NAME</CODE></EM>.</CODE> to generate a header 
file. For example: <SPAN><STRONG class=command>dbus-binding-tool 
--mode=glib-server my-object.xml &gt; my-object-glue.h</STRONG></SPAN>. </P>
<P>Next, include the generated header in your program, and invoke <CODE 
class=literal>dbus_g_object_class_install_info</CODE> in the class initializer, 
passing the object class and "object info" included in the header. For example: 
</P><PRE class=programlisting>	dbus_g_object_type_install_info (COM_FOO_TYPE_MY_OBJECT, &amp;com_foo_my_object_info);
      </PRE>
<P>This should be done exactly once per object class. </P>
<P>To actually implement the method, just define a C function named e.g. <CODE 
class=literal>my_object_many_args</CODE> in the same file as the info header is 
included. At the moment, it is required that this function conform to the 
following rules: </P>
<DIV class=itemizedlist>
<UL type=disc>
  <LI>
  <P>The function must return a value of type <CODE 
  class=literal>gboolean</CODE>; <CODE class=literal>TRUE</CODE> on success, and 
  <CODE class=literal>FALSE</CODE> otherwise. </P>
  <LI>
  <P>The first parameter is a pointer to an instance of the object. </P>
  <LI>
  <P>Following the object instance pointer are the method input values. </P>
  <LI>
  <P>Following the input values are pointers to return values. </P>
  <LI>
  <P>The final parameter must be a <CODE class=literal>GError **</CODE>. If the 
  function returns <CODE class=literal>FALSE</CODE> for an error, the error 
  parameter must be initalized with <CODE class=literal>g_set_error</CODE>. 
  </P></LI></UL></DIV>
<P></P>
<P>Finally, you can export an object using <CODE 
class=literal>dbus_g_connection_register_g_object</CODE>. For example: </P><PRE class=programlisting>	  dbus_g_connection_register_g_object (connection,
                                               "/com/foo/MyObject",
                                               obj);
      </PRE>
<P></P>
<DIV class=sect2 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=glib-annotations></A>Server-side 
Annotations</H3></DIV></DIV></DIV>
<P>There are several annotations that are used when generating the server-side 
bindings. The most common annotation is <CODE 
class=literal>org.freedesktop.DBus.GLib.CSymbol</CODE> but there are other 
annotations which are often useful. </P>
<DIV class=variablelist>
<DL>
  <DT><SPAN class=term><CODE 
  class=literal>org.freedesktop.DBus.GLib.CSymbol</CODE></SPAN>
  <DD>
  <P>This annotation is used to specify the C symbol names for the various types 
  (interface, method, etc), if it differs from the name DBus generates. </P>
  <DT><SPAN class=term><CODE 
  class=literal>org.freedesktop.DBus.GLib.Async</CODE></SPAN>
  <DD>
  <P>This annotation marks the method implementation as an asynchronous 
  function, which doesn't return a response straight away but will send the 
  response at some later point to complete the call. This is used to implement 
  non-blocking services where method calls can take time. </P>
  <P>When a method is asynchronous, the function prototype is different. It is 
  required that the function conform to the following rules: </P>
  <DIV class=itemizedlist>
  <UL type=disc>
    <LI>
    <P>The function must return a value of type <CODE 
    class=literal>gboolean</CODE>; <CODE class=literal>TRUE</CODE> on success, 
    and <CODE class=literal>FALSE</CODE> otherwise. TODO: the return value is 
    currently ignored. </P>
    <LI>
    <P>The first parameter is a pointer to an instance of the object. </P>
    <LI>
    <P>Following the object instance pointer are the method input values. </P>
    <LI>
    <P>The final parameter must be a <CODE class=literal>DBusGMethodInvocation 
    *</CODE>. This is used when sending the response message back to the client, 
    by calling <CODE class=literal>dbus_g_method_return</CODE> or <CODE 
    class=literal>dbus_g_method_return_error</CODE>. </P></LI></UL></DIV>
  <P></P>
  <DT><SPAN class=term><CODE 
  class=literal>org.freedesktop.DBus.GLib.Const</CODE></SPAN>
  <DD>
  <P>This attribute can only be applied to "out" <CODE 
  class=literal>&lt;arg&gt;</CODE> nodes, and specifies that the parameter isn't 
  being copied when returned. For example, this turns a 's' argument from a 
  <CODE class=literal>char **</CODE> to a <CODE class=literal>const char 
  **</CODE>, and results in the argument not being freed by DBus after the 
  message is sent. </P>
  <DT><SPAN class=term><CODE 
  class=literal>org.freedesktop.DBus.GLib.ReturnVal</CODE></SPAN>
  <DD>
  <P>This attribute can only be applied to "out" <CODE 
  class=literal>&lt;arg&gt;</CODE> nodes, and alters the expected function 
  signature. It currently can be set to two values: <CODE 
  class=literal>""</CODE> or <CODE class=literal>"error"</CODE>. The argument 
  marked with this attribute is not returned via a pointer argument, but by the 
  function's return value. If the attribute's value is the empty string, the 
  <CODE class=literal>GError *</CODE> argument is also omitted so there is no 
  standard way to return an error value. This is very useful for interfacing 
  with existing code, as it is possible to match existing APIs. If the 
  attribute's value is <CODE class=literal>"error"</CODE>, then the final 
  argument is a <CODE class=literal>GError *</CODE> as usual. </P>
  <P>Some examples to demonstrate the usage. This introspection XML: </P><PRE class=programlisting>&lt;method name="Increment"&gt;
  &lt;arg type="u" name="x" /&gt;
  &lt;arg type="u" direction="out" /&gt;
&lt;/method&gt;
                </PRE>
  <P>Expects the following function declaration: </P><PRE class=programlisting>gboolean
my_object_increment (MyObject *obj, gint32 x, gint32 *ret, GError **error);
                </PRE>
  <P></P>
  <P>This introspection XML: </P><PRE class=programlisting>&lt;method name="IncrementRetval"&gt;
  &lt;arg type="u" name="x" /&gt;
  &lt;arg type="u" direction="out" &gt;
    &lt;annotation name="org.freedesktop.DBus.GLib.ReturnVal" value=""/&gt;
  &lt;/arg&gt;
&lt;/method&gt;
                </PRE>
  <P>Expects the following function declaration: </P><PRE class=programlisting>gint32
my_object_increment_retval (MyObject *obj, gint32 x)
                </PRE>
  <P></P>
  <P>This introspection XML: </P><PRE class=programlisting>&lt;method name="IncrementRetvalError"&gt;
  &lt;arg type="u" name="x" /&gt;
  &lt;arg type="u" direction="out" &gt;
    &lt;annotation name="org.freedesktop.DBus.GLib.ReturnVal" value="error"/&gt;
  &lt;/arg&gt;
&lt;/method&gt;
                </PRE>
  <P>Expects the following function declaration: </P><PRE class=programlisting>gint32
my_object_increment_retval_error (MyObject *obj, gint32 x, GError **error)
                </PRE>
  <P></P></DD></DL></DIV>
<P></P></DIV></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A name=python-client></A>Python 
API</H2></DIV></DIV></DIV>
<P>The Python API, dbus-python, is now documented separately in <A 
href="http://dbus.freedesktop.org/doc/dbus-python/doc/tutorial.html" 
target=_top>the dbus-python tutorial</A> (also available in doc/tutorial.txt, 
and doc/tutorial.html if built with python-docutils, in the dbus-python source 
distribution). </P></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A name=qt-client></A>Qt API: Using Remote 
Objects</H2></DIV></DIV></DIV>
<P>The Qt bindings are not yet documented. </P></DIV>
<DIV class=sect1 lang=en>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A name=qt-server></A>Qt API: Implementing 
Objects</H2></DIV></DIV></DIV>
<P>The Qt bindings are not yet documented. </P></DIV></DIV></BODY></HTML>
